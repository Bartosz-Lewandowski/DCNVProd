import pandas as pd
import numpy as np
import scipy.stats
import os
"""
input is generated by genomeCoverageBed -d in the following format:
CHR POS COVERAGE
Following that, per chromosome, find the median coverage of covered bases.
Can find median for all chromosomes or a specified set of them, one chromosome ID per line.
"""
bedtools_path = "/usr/bin/bedtools"
os.system(bedtools_path + " genomecov -d -ibam " + "sim_train/total.bam" + " > temp_covsperbase.bed")
print("Calculating median coverage")
test = pd.read_table("temp_covsperbase.bed",header=None)
covs_median = {}
splits_median = {}

print("Calculating relative median coverage per window")
chr_stats = []
covs_median[1] = test[2][test[2] != 0][test[0] == 1].median()
print(1,covs_median[1])
count = 0
"function takes in a pandas dataframe column and outputs a dataframe containing the start and end of window, as well as window coverage median and standard deviation"
def rolling_with_step(chr,s, window, step):
    vert_idx_list = np.arange(1, s.size - window, step)
    hori_idx_list = np.arange(window)
    A, B = np.meshgrid(hori_idx_list, vert_idx_list)
    idx_array = A + B
    x_array = s.values[idx_array]
    idx = list(s.index[vert_idx_list + (int(window))])
    med = list(np.around(list(map(np.median, x_array)),4))
    intq = list(np.around(list(map(scipy.stats.iqr, x_array)),4))
    means = list(np.around(list(map(np.mean, x_array)),4))
    std = list(np.around(list(map(np.std, x_array)),4))
    return pd.DataFrame({"chr":chr,"start":vert_idx_list,"end":vert_idx_list + window,"med":med,"iqr":intq,"mean":means,"std":std})
out_df = pd.DataFrame(columns=["chr","start","end","med","iqr","mean","std"])
"""
For each chromosome, divide each base by the chromosome median (or total median).
Following that, finds the median and standard deviation for windows of a given size
"""
for i in covs_median:
    test_chrs = test[test[0] == i]
    test_chrs_3 = test_chrs[2]/covs_median[i]
    wins_step = rolling_with_step(i,test_chrs_3,50-1,50)
    print("Chromosome " + str(i) + " processed")
    out_df = pd.concat([out_df,wins_step])
out_df['chr']=out_df['chr'].astype(str)
out_df['start']=out_df['start'].astype(int)
out_df['end']=out_df['end'].astype(int)
out_df.to_csv("output.bed",sep="\t",index =False,columns=None,header=None)
os.remove("temp_covsperbase.bed")